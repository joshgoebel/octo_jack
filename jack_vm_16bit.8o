# Chip8 is a virtual machine designed in 1977 for programming video games.
# Octo is a high level assembler, disassembler and simulator for Chip8.
# Click 'Run' and then press ASWD to move the sprite around the screen.
# Click the Octo logo for source, documentation and examples.

:macro indirect LABEL {
	0xF0 0x00 : LABEL 0x00 0x00 # i := long NNNN
	}

:const FALSE 0x0000
:const TRUE  0x0001

#:alias LOCALS v8 # pointer into stack
#:alias ARGS v9 # pointer into stack
:alias SP vC
:alias index vE

:alias op1 v2
:alias op2 v3
:alias op3 v4
:alias op4 v5 # rare

:alias tmp v7

:alias PChi v8
:alias PClo v9

:macro op CODE {
  # 5 bit opcode
	:byte { CODE << 2 }
}
:macro o_push_constant CONST {
	:calc hi { ( CONST >> 8 ) & 0xFF }
	:calc lo {  CONST & 0xFF }
	op 0x20
	:byte { hi }
	:byte { lo }
}

:macro o_push_static INDEX { op 0x11 :byte { INDEX } }
:macro o_pop_static INDEX { op 0x19 :byte { INDEX } }
:macro o_push_local INDEX { op 0x12 :byte { INDEX } }
:macro o_pop_local INDEX { op 0x1A :byte { INDEX } }

:macro noop { 0x00 }
:macro o_add { op 0x01 }
:macro o_sub { op 0x02 }
:macro o_negate { op 0x03 }
:macro o_equal { op 0x04 }
:macro o_gt { op 0x05 }
:macro o_lt { op 0x06 }
:macro o_and { op 0x07 }
:macro o_or { op 0x08 }
:macro o_xor { op 0x09 }
:macro o_not { op 0x0A }
:macro o_halt { op 0x17 0x00 }

:macro o_jump ADDR16 {
	:calc hi { ( ADDR16 >> 8 ) & 0xFF }
	:calc lo {  ADDR16 & 0xFF }
	op 0x21
	:byte { hi }
	:byte { lo }
}

:macro o_jump_if ADDR16 {
	:calc hi { ( ADDR16 >> 8 ) & 0xFF }
	:calc lo {  ADDR16 & 0xFF }
	op 0x22
	:byte { hi }
	:byte { lo }
}



# statics and stack are fixed in RAM
:org 0x1900
: statics

:org 0x2000
: stack

:org 0x0F00
:const ptr_count 6
:const ptr_size 6
: access_stack
indirect stack_ptr
;
: access_this
indirect this_ptr
;
: access_that
indirect that_ptr
;
: access_args
indirect args_ptr
;
: access_locals
indirect locals_ptr
;
: access_statics
i := long statics
;

:monitor stack_ptr "%2i"
:monitor args_ptr "%2i"
:monitor locals_ptr "%2i"
:monitor this_ptr "%2i"
:monitor that_ptr "%2i"
:monitor statics "%2i %2i %2i %2i %2i %2i %2i %2i %2i %2i %2i %2i %2i"
:monitor stack "%2i %2i %2i %2i %2i %2i %2i %2i %2i %2i %2i %2i %2i"

:macro push_constant CONST {
  i := long stack
	i += SP
	vF := CONST
	save vF - vF
	SP += 1
}


:macro jump-if LABEL {
	#:breakpoint x
  i := long stack
	SP -= 1
	i += SP
	load tmp - tmp
	if tmp != 0 then jump LABEL
}

:macro load_addr PTR {
	:calc hi { ( PTR >> 8 ) & 0xFF }
	:calc lo { PTR & 0xFF }
	vE := hi
	vF := lo
}

:macro save_ptr {
  save vE - vF
}


:macro copy_ptr SRC DEST {
	i := long SRC
	load vD - vE
	i := long DEST
	save vD - vE
}

:macro get_static POS {
	index := POS
	_get_static
}

:macro pop_static POS {
	index := POS
	_pop_static
}

:macro get_local POS {
	index := POS
	_get_local
}

:macro pop_local POS {
	index := POS
	_pop_local
}

:macro push_local IDX {
	index := IDX
	_push_local
}

:macro push_static IDX {
	index := IDX
	_push_static
}



:macro push_wconstant CONST {
	:calc hi { ( CONST >> 8 ) & 0xFF }
	:calc lo { CONST & 0xFF }
	# save value to stack
	vC := hi
	vD := lo
	access_stack
	save vC - vD

	stack_inc
}






:macro assert_equal REG VALUE {
	if REG != VALUE begin
		test-fail
		#:breakpoint "assert_equal failed"
		return
	end
}

:org 0x200
: main
vF := 1
#:breakpoint x
vF := 1
vF := 1
#:call 0xfff
jump start

: test_green 0x00 0x80
: test_red 0x80 0x80
: test_state 0x00


:const MAX_TESTS 30
:calc next_test { HERE }
: run_tests
#:breakpoint tests
: tests

:org { tests + MAX_TESTS * 2 }
return

:monitor tests 12

: start
	v0 := 0
	i := test_state
	save v0 - v0

	plane 3
	SP := 0
#	ZERO := 0
	i := long stack_ptr
	load_addr 0x2000
	save_ptr
	copy_ptr stack_ptr args_ptr

	#push_wconstant 1
	#push_wconstant 2
	#addw
	#pop_static 0
#	add

	#test_a_plus_b
	#test_a_equal_b
	#:breakpoint x

	#:breakpoint before_run_tests
	:call run_tests
	#:breakpoint after_run_tests

	loop
	  vF += 1
	again

: advance_test
	i := test_state
	load v0 - v0
	v0 += 1
	save v0 - v0
;

: test-fail
	advance_test
	i := test_red
	sprite v0 v0 1
;

: success
	advance_test
	i := test_green
	sprite v0 v0 1
;

:macro test NAME {
	:calc curr_test { HERE }
	:org next_test
	:call curr_test
	:calc next_test { HERE }
	:org curr_test
}

:macro pop_into_reg REG1 {
	:alias REG2 { REG1 + 1 }
	:calc load_ref { HERE }
	stack_dec
	access_stack
	load REG1 - REG2
}

:macro assert_equal_16 REGPAIR VALUE {
	:alias REG2 { REGPAIR + 1 }

  :assert "vF not an allowed pair" { REGPAIR != vF }
	:assert "vE not an allowed pair" { REGPAIR != vE }
	:calc hi { ( VALUE & 0xFF00 ) >> 8 }
	:calc low { VALUE & 0xFF }
	if REGPAIR != hi begin
		test-fail
		return
	end
	if REG2 != low begin
		test-fail
		return
	end
}

:macro vm_start {
	:calc vm_source { HERE }
	:calc next_inst { HERE + 2 }
	:org next_inst
}

:macro inc_pc n {
	# need a register to get overflow flag in vF
	vF := n
	PClo += vF
	PChi += vF # overflow
}
: load_pc
	indirect pc_addr
;
: run_vm
	i := pc_addr
	save PChi - PClo
	load_pc
	load op1 - op3
	v0 := op1
	v0 >>= v0
#	v0 += 1
	#:breakpoint xs
	jump0 op_jump_table
	: op_done_resume_vm
	inc_pc 1
	: op_done_resume_vm_at_new_PC
	jump run_vm
return

:monitor 0x29a 10

:macro vm_stop {
	o_halt
	:calc was { HERE }
	# now go back and insert a jump
	:org vm_source
	jump was
	:calc vm_source { vm_source + 2 }
	:org was
	# load vm_source into our PC
	:calc hi { ( vm_source >> 8 ) & 0xFF }
	:calc lo { vm_source & 0xFF }
	PChi := hi
	PClo := lo
	#:breakpoint running_vm
	run_vm
}


# tests

:include tests/sys

:include tests/math/add
:include tests/math/sub
:include tests/math/and
:include tests/math/or
:include tests/math/negate
:include tests/math/not
:include tests/math/equal
:include tests/math/greater_than
:include tests/math/less_than



# todo: move into statics?
:macro memcpy src dest count {
	index := count
	:calc memcpy_return { HERE }
	index -= 1
	i := long src
	i += index
	load vF - vF
	i := long dest
	i += index
	save vF - vF
	if index != 0 then jump memcpy_return
}

:include tests/push_pop/static


:macro memcpy_dir_to_ptr src dest_ptr count {
	index := count
	:calc memcpy_return { HERE }
	index -= 1
	i := long src
	i += index
	load vF - vF
	# i := long dest_ptr
	:call { dest_ptr - 2 }
	i += index
	save vF - vF
	if index != 0 then jump memcpy_return
}

:include tests/push_pop/local


# bookends
:calc was { HERE }
:org next_test
:breakpoint done
return
:org was

: _get_static
	access_statics
	index += index # double
	i += index
	load vC - vD
;

: _get_local
	access_locals
	index += index # double
	i += index
	load vC - vD
;

	#:breakpoint x
	#push_constant 3
	#equal
#	push_constant 0
#	:breakpoint push_0
#	not
#push_constant 49
#push_constant 44
#neg
#:breakpoint t
#add

#	push_constant 9
#	push_constant 4
#	Math_add
#	push_constant 13
	#:breakpoint y
#	equal
	#:breakpoint x
#	jump-if true
#	jump done
#	: true
#		push_constant 59
#	: done
;

# PUSH OPCODES

# [x] push constant
# [x] push static
# [x] push local
# [ ] push this
# [ ] push that
# [ ] push arg


: _push_local
	index += index # words, not bytes
	access_locals
	i += index
	load vC - vD
	access_stack
	save vC - vD
	stack_inc
return

: _push_static
	index += index # words, not bytes
	access_statics
	i += index
	load vC - vD
	access_stack
	save vC - vD
	stack_inc
return


# POP OPCODES

# [x] pop static
# [x] pop local
# [ ] pop this
# [ ] pop that
# [ ] pop arg?????

: _pop_static
	stack_dec
	access_stack
	load vC - vD
	access_statics
	index += index
	i += index
	save vC - vD
;

: _pop_local
	stack_dec
	access_stack
	load vC - vD
	access_locals
	index += index
	i += index
	save vC - vD
;


:include lib/math
:include lib/stack





:macro push_arg X {
  vF := X
  _push_arg
}

:alias arg_num vF
: _push_arg
  i := long stack
	i += v0 # ARGS
	i += arg_num
	load vF - vF
	i := long stack
	i += SP
	save vF - vF
	SP += 1
return

: do_return
  i := long stack
	SP -= 1
	i += SP
	load tmp - tmp
	# rewind stack
	SP := v0 # ARGS
	i := long stack
	i += SP
	save tmp - tmp
	SP += 1
;

# encoding

:macro op_return {
  jump op_done_resume_vm
}





:include ops/hardware
:include ops/push
:include ops/pop
:include ops/math


# flow control

: op_halt
# purposely all this does is return (a REAL return, not op_return)
# and since we jumped here this will terminate the VM
#
# TODO: perhaps instead a jump to vm_stop might be
# more appropriate if later we decide we have cleanup
# we need to do.
#	inc_pc 1
return

: op_call_method
return

:alias tmpHi op2
:alias tmpLo op3
: op_call_fn
	# fetch ALL the opcode need the 4th byte)
	load op1 - op4
	# push PC (for return)
	access_stack
	save PChi - PClo
	stack_inc
	# save the new PC to free up those registers for use
	PChi := op2
	PClo := op3

	# push this ptr
	i := long this_ptr
	load tmpHi - tmpLo
	access_stack
	save tmpHi - tmpLo
	stack_inc

	# push that ptr
	i := long that_ptr
	load tmpHi - tmpLo
	access_stack
	save tmpHi - tmpLo
	stack_inc

	# push args ptr
	i := long args_ptr
	load tmpHi - tmpLo
	access_stack
	save tmpHi - tmpLo
	stack_inc

	# push local ptr
	i := long locals_ptr
	load tmpHi - tmpLo
	access_stack
	save tmpHi - tmpLo
	stack_inc

	# new this ptr and new that ptr
	tmpHi := 0
	tmpLo := 0
	i := long this_ptr
	save tmpHi - tmpLo
	i := long that_ptr
	save tmpHi - tmpLo

	# new locals ptr (here, top of stack currently - before we push locals)
	i := long stack_ptr
	load tmpHi - tmpLo
	i := long locals_ptr
	save tmpHi - tmpLo

	# new args ptr (rewind stack (# args + 1[PC]) * 2)
	:const FRAME_SIZE 10 # 5 word ptrs: PC, this, that, args, locals
	i := long stack_ptr
	load tmpHi - tmpLo
	op4 += op4 # words, not bytes
	op4 += FRAME_SIZE
	tmpLo -= op4
	tmpHi -= vF
	i := long args_ptr
	save tmpHi - tmpLo

	# GO JUMP
	jump op_jump
return

: op_function
	# op2: number of 16-bit locals
	index := op2
	v1 := 0
	v2 := 0
	# push zeroed locals onto the stack
	loop while index != 0
		access_stack
		save v1 - v2
		stack_inc
		index -= 1
	again
	# TODO: set locals_ptr or does call do that?
	inc_pc 1 # eat number of locals
op_return
return

: op_jump
	PChi := op2
	PClo := op3
	# we need to return without bumping SP after we return
	jump op_done_resume_vm_at_new_PC
	# op_return
return

# pop top value from stack, jump only if true
: op_jump_if
	stack_dec
	access_stack
	load vC - vD
	vC |= vD
	if vC == FALSE begin
		# skip over the jump address
		inc_pc 2
		# no jump we are falsy, return without touching PC
		op_return
	end
	# truthy value, lets do the jump opcode
	jump op_jump
return

: opcode_return
return



# 2 bit | 6 bit

# 0x00 NOP

# 0 0 0x1 add
# 0 0 0x2 sub
# 0 0 0x3 neg
# 0 0 0x4 equal
# 0 0 0x5 gt
# 0 0 0x6 lt
# 0 0 0x7 and (bool/logic)
# 0 0 0x8 or (bool/logic)
# 0 0 0x9 xor (logic)
# 0 0 0xA not (bool)

:calc was { HERE }
:org 0xFF0
: highwater
:byte { ( was >> 8 ) & 0xff }
:byte { was & 0xff }
:monitor highwater "%2i"




# 1 1 [index] pop static     (2 byte)
# 1 2 [index] pop local      (2 byte)
# 1 3 [index] pop this       (2 byte)
# 1 4 [index] pop that       (2 byte)
# 1 5 [index] pop arg?????   (2 byte)

# 2 1 push constant [word]   (3 bytes)
# 2 2 push constant [3 bit]  (1 byte)
# 2 3 [index] push static    (2 byte)
# 2 4 [index] push local     (2 byte)
# 2 5 [index] push this      (2 byte)
# 2 6 [index] push that      (2 byte)
# 2 7 [index] push arg       (2 byte)

# 3 1 jump [addr][addr]      (3 bytes)
# 3 2 jump-if [addr][addr]   (3 bytes)
# 3 3 call_fn [addr][addr] [args] (4 bytes)
# 3 4 call_method [addr][addr] [args] (4 bytes) (this is pushed on stack first)
# 3 5 function [locals]      (2 bytes)
# 3 6 return                 (1 byte)



#: op_jump_table_low_ram
#:org 0xFFF
#:byte 0

:include jump_table
